{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Era of Connected Vehicles","text":"<p>Vehicular Ad Hoc Networks (VANETs) represent a specialized form of mobile ad hoc networks designed to enable communication between vehicles and infrastructure. In VANETs, vehicles equipped with wireless communication capabilities form a dynamic network, exchanging information to enhance road safety and traffic efficiency. Utilizing technologies like Dedicated Short Range Communication (DSRC), VANETs facilitate communication between vehicles and roadside infrastructure, enabling features such as collision avoidance, traffic management, and emergency response coordination. These networks play a pivotal role in the development of intelligent transportation systems, contributing to the evolution of connected and autonomous vehicles for safer and more efficient mobility.</p> <p></p>"},{"location":"cartrac/","title":"CarTrac Testbed","text":"<p>The name of the funded VANET project is Collaborative Trusted Anony-mous Communication in Vehicular Networks (CARTRAC). The real implementation of VANET is expensive and requires more manpower. Conducting experiments in real roadtraffic is difficult and risky. </p> <p></p> <p>Therefore, an ad hoc network was created, and experiments were conducted using low-cost Raspberry Pi devices mounted on RC cars. The low-cost testbed includes a Raspberry Pi model B device, a GPS module(antenna and receiver) for the position information, a magnetometer for retrieving the direction information, and ahigh-speed racing Remote Controlled (RC) car. The raspbian OS was installed on the raspberry pi. The GPS module and magnetometer are connected to the Raspberry Pi and configured as an OBU. The Raspberry Pi is configured in adhocmode and a power bank supplies power to the configured OBU. The OBU is mounted on the top of the RC car and stra-pped around it.</p> <p></p> <p>The high-speed racing RC cars (model 144001) were used for the experiments. RC cars moved up to a speed of 60 km/h and was used in the experiments. The remote controller works at 2.4 GHz and cansupport a length of 100 m. The car's body is made of high-strength aluminium alloy with strong stability, zinc alloy gears,and oil-pressure shock absorbers for strong wear resistance. Its high efficiency 550 strong magnetic motors support fastto and fro motion.</p> <p></p> <p>The testbed helps to implement and test the following:</p> <ul> <li> <p>Routing protocols</p> </li> <li> <p>Synthetic mobility trace</p> </li> <li> <p>Security algorithm</p> </li> <li> <p>Security attacks</p> </li> <li> <p>Transport protocol</p> </li> <li> <p>Handover</p> </li> <li> <p>Clustering and creating platoons</p> </li> <li> <p>Safety message dissemination</p> </li> </ul> <pre><code>Sarath Babu, and Arun Raj Kumar P. \"A comprehensive survey on simulators, \nemulators, and testbeds for VANETs.\" International Journal of Communication\n Systems 35.8 (2022): e5123.\n</code></pre>"},{"location":"communication/","title":"Node's Communication","text":""},{"location":"communication/#infrastructure-mode-and-communication","title":"Infrastructure mode and communication","text":"<p>Infrastructure-based networks rely on a centralized infrastructure, typically consisting of routers, access points, and base stations. Devices in these networks connect to this fixed infrastructure to communicate with each other and access resources. The centralized nature of the infrastructure allows for better management, scalability, and reliability, making these networks ideal for scenarios where a consistent and managed network is essential.</p>"},{"location":"communication/#fix-static-ip-in-the-wireless-interface-of-the-pis","title":"Fix static ip in the wireless interface of the pi\u2019s","text":"<p>Enter into dhcpcd.conf </p> <pre><code>    sudo nano /etc/dhcpcd.conf\n</code></pre> <p>Add the static configurations Example:</p> <pre><code>    interface wlan0\n    static ip_address=192.168.1.101/24\n    static routers=192.168.1.1\n    static domain_name_servers=192.168.1.1\n</code></pre> <ul> <li>Ping and show the network is reachable.</li> <li>Write UDP client socket program to sending and receiving the messages </li> <li>Exchage the sensor collected values</li> </ul>"},{"location":"communication/#ad-hoc-mode-and-communication","title":"Ad Hoc mode and communication","text":"<p>Ad hoc networks are decentralized and dynamic communication systems that form spontaneously without the need for a pre-existing infrastructure. In ad hoc networks, devices communicate directly with each other, allowing for quick and flexible connectivity in scenarios where a centralized infrastructure is impractical or unavailable. Ad hoc networks are well-suited for situations such as emergency response, military operations, or temporary gatherings, where the ability to establish a network on-the-fly is crucial.</p>"},{"location":"communication/#adhoc-setup","title":"Adhoc setup","text":"<ul> <li>Show the configuration using iwconfig and ifconfig</li> <li>Setup raspberry pi wireless interface to ad-hoc mode</li> </ul> <p>Modify interface file</p> <pre><code> /etc/network/interfaces\n</code></pre> <pre><code>    auto lo\n    iface lo inet loopback\n\n    auto eth0\n    iface eth0 inet dhcp\n\n    auto wlan0\n    iface wlan0 inet static\n    address 10.1.1.1\n    netmask 255.255.255.0\n    wireless-channel 5\n    wireless-essid VANET\n    wireless-mode ad-hoc\n</code></pre>"},{"location":"communication/#communication-between-adhoc-nodes","title":"Communication between adhoc nodes","text":"<ul> <li>Write socket program to communicate between the nodes</li> <li>Exchange the the position information</li> <li>Write code to for periodic becon message</li> </ul>"},{"location":"rasp/","title":"Familiarization to raspberry pi","text":"<p>Raspberry Pi is a credit card-sized, single-board computer developed by the Raspberry Pi Foundation. Launched with the primary goal of promoting computer science education and fostering DIY projects, the Raspberry Pi has gained widespread popularity for its versatility and affordability. Powered by a Broadcom system-on-a-chip (SoC), it provides a fully functional computer with USB ports, HDMI output, GPIO (General Purpose Input/Output) pins, and networking capabilities. Despite its compact size and modest cost, the Raspberry Pi can run a variety of operating systems, making it an ideal platform for educational purposes, home automation, media centers, and numerous other applications. Its accessibility has fueled a vibrant community of enthusiasts, developers, and educators who continually explore innovative uses for this small yet powerful computing device.</p> <p></p>"},{"location":"rasp/#software-and-installation","title":"Software and Installation","text":"<p>Raspberry Pi OS, formerly known as Raspbian, is the official operating system designed for the Raspberry Pi single-board computers. It is a Debian-based Linux distribution tailored specifically for the Raspberry Pi's ARM architecture. The OS provides a user-friendly environment and comes with essential software tools, including a web browser, office suite, and programming environments. Its lightweight nature makes it well-suited for the limited resources of the Raspberry Pi hardware. Raspberry Pi OS supports a variety of applications and is widely used for educational purposes, DIY projects, and as a platform for learning programming and computing skills. Its modular design allows users to customize and expand their systems according to their specific needs, making it a versatile choice for a range of projects and applications.</p>"},{"location":"rasp/#download-raspberry-pi-os","title":"Download Raspberry Pi OS","text":"<p>Download OS </p>"},{"location":"rasp/#to-install-os","title":"To install OS","text":"<ul> <li> <p>Raspberry Pi Imager is the quick and easy way to install OS in memorycard.</p> </li> <li> <p>Install Imager into system (https://www.raspberrypi.com/software/)</p> </li> </ul>"},{"location":"rasp/#to-install-imager-on-ubuntu","title":"To install Imager on Ubuntu","text":"<p>Open Terminal and run</p> <pre><code>        sudo apt install rpi-imager\n</code></pre>"},{"location":"rasp/#to-install-imager-on-windows","title":"To install Imager on Windows","text":"<p>Download Imager for Windows</p>"},{"location":"rasp/#connecting-rasberry-pi","title":"Connecting Rasberry Pi","text":""},{"location":"rasp/#pin-diagram-of-rasberry-pi","title":"Pin diagram of Rasberry Pi","text":"<p>The Raspberry Pi features a set of GPIO (General Purpose Input/Output) pins, which serve as a key component for interfacing with external devices and expansion. These pins are designed to offer versatility and are programmable to function either as input or output. The Raspberry Pi Model B typically includes 40 GPIO pins, providing connectivity for various purposes such as connecting sensors, LEDs, or other peripherals. Additionally, these pins support protocols like I2C, SPI, and UART, enhancing the device's adaptability for a wide range of projects and applications.</p> <p>Type pinout in command line to output the available pins.</p> <pre><code>        pinout\n</code></pre> <p></p> <p>you need to enable or configure GPIO (General Purpose Input/Output) pins on the Raspberry Pi when connecting sensors. GPIO pins on the Raspberry Pi often default to a general-purpose mode, and you may need to set them up for specific functionalities relevant to your sensor.</p> <p>Common scenarios:</p> <ol> <li> <p>Digital Sensors: For digital sensors that use GPIO pins for input or output, you typically need to configure the pins to act as inputs or outputs. This might involve using software libraries or configuring the pins in your code.</p> </li> <li> <p>Analog Sensors: If you are connecting analog sensors, you may need to use specific pins that support analog-to-digital conversion. In this case, you would need to configure the pins accordingly.</p> </li> <li> <p>Communication Protocols (I2C, SPI, etc.): Many sensors communicate using protocols like I2C or SPI. In such cases, you need to enable the respective communication interface and connect the sensor to the appropriate pins.</p> </li> </ol>"},{"location":"rasp/#enable-port","title":"Enable port","text":"<pre><code>        sudo raspi-config\n</code></pre> <p>Follow operations:</p> <pre><code>    Interface option -&gt; S6 Serial Port\n    Serial login shell -&gt; disable\n    Serial interface -&gt; enable\n</code></pre> <p>Before connecting sensors, it's crucial to refer to the datasheets of both the sensor and the  Raspberry Pi to ensure proper pin configuration. Additionally, software libraries or drivers may need to be installed or configured to communicate with the sensor properly.</p>"},{"location":"sensor/","title":"Sensor Connection","text":"<p>Connecting sensors to a Raspberry Pi involves establishing a communication interface between the sensor and the GPIO (General Purpose Input/Output) pins on the Raspberry Pi board. Sensors, which capture physical data such as temperature, light, or motion, often have specific pin requirements and communication protocols. Users need to identify and configure the GPIO pins appropriately, ensuring compatibility with the sensor's specifications. Additionally, software libraries or drivers may be necessary to facilitate communication between the Raspberry Pi and the sensor. This integration allows the Raspberry Pi to collect data from the sensor, opening up possibilities for diverse applications, ranging from environmental monitoring to home automation.</p> <p> </p>"},{"location":"sensor/#gps-sensor","title":"GPS Sensor","text":"<p>A GPS (Global Positioning System) sensor is a device designed to determine and track the precise geographical location of an object or individual by receiving signals from a network of satellites orbiting the Earth. The working principle of a GPS sensor involves triangulation, where signals from at least three satellites are used to calculate the user's exact position in three-dimensional space. The sensor receives signals from these satellites, each transmitting information about its location and the precise time of signal transmission. By measuring the time it takes for signals to travel from the satellites to the GPS receiver, the sensor can determine the distance from each satellite. With information from multiple satellites, the GPS sensor can then calculate the user's latitude, longitude, and altitude. GPS sensors have become integral in various applications, including navigation systems, mapping, outdoor activities, and asset tracking, providing accurate and real-time location data.</p>"},{"location":"sensor/#how-gps-works","title":"How GPS Works","text":"<p>GIF Source: Wikipedia</p> <p>The GPS receiver uses a constellation of satellites and ground stations to calculate accurate location wherever it is located. These GPS satellites transmit information signals over radio frequency (1.1 to 1.5 GHz) to the receiver. With the help of this received information, a ground station or GPS module can compute its position and time.</p>"},{"location":"sensor/#how-gps-receiver-calculates-its-position-and-time","title":"How GPS Receiver Calculates its Position and Time","text":"<p>GPS receiver receives information signals from GPS satellites and calculates its distance from satellites. This is done by measuring the time required for the signal to travel from the satellite to the receiver.</p> <p>Distance = Speed x Time Where,</p> <p>Speed = Speed of Radio signal which is approximately equal to the speed of light. </p> <p>Time = Time required for a signal to travel from the satellite to the receiver.</p> <p>By subtracting the sent time from the received time, we can determine the travel time.</p> <p>To determine distance, both the satellite and GPS receiver generate the same pseudocode signal at the same time.</p> <p>The satellite transmits the pseudocode; which is received by the GPS receiver. These two signals are compared and the difference between the signals is the travel time. Now, if the receiver knows the distance from 3 or more satellites and their location (which is sent by the satellites), then it can calculate its location by using the Trilateration method.</p>"},{"location":"socketprogramming/","title":"Socket programming","text":"<p>Socket programming is a fundamental concept in network communication that enables the exchange of data between two entities over a network. Sockets provide a standard mechanism for processes running on different devices to communicate seamlessly. In socket programming, a socket represents an endpoint for sending or receiving data across a computer network.</p>"},{"location":"socketprogramming/#key-concepts-in-socket-programming","title":"Key concepts in socket programming:","text":"<ul> <li> <p>Server and Client:</p> <p>The server is a program or device that provides services or resources. The client is a program or device that requests services or resources from the server.</p> </li> <li> <p>Socket Creation:</p> <p>Sockets are created using programming interfaces, such as the Berkeley Sockets API in Unix-like systems. A server creates a socket to listen for incoming connections, while a client creates a socket to initiate a connection to the server.</p> </li> <li> <p>Socket Binding:</p> <p>The server binds its socket to a specific address and port to listen for incoming connections. The client specifies the server's address and port when connecting.</p> </li> <li> <p>Connection Establishment:</p> <p>The server listens for incoming connections, and the client initiates a connection request. Once a connection is established, data can be exchanged between the server and client.</p> </li> <li> <p>Data Transfer:</p> <p>Data is transferred between the server and client using methods like send() and recv() in programming languages like Python or C. Sockets provide a bi-directional communication channel for data exchange.</p> </li> <li> <p>Socket Closing:</p> <p>Sockets are closed after data transfer is complete or when the connection is no longer needed. Proper socket closure ensures the release of resources and termination of the connection.</p> </li> </ul> <p>Socket programming is widely used in various applications, including web development, network protocols, and distributed systems. It provides a flexible and efficient way for applications to communicate and share information across a network.</p>"},{"location":"socketprogramming/#udp-socket-client-server-program-in-python","title":"UDP socket client-server program in Python","text":""},{"location":"socketprogramming/#udp-server","title":"UDP Server","text":"<pre><code>import socket\n\n# Define server address and port\nserver_address = ('localhost', 12345)\n\n# Create a UDP socket\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Bind the socket to the server address\nserver_socket.bind(server_address)\n\nprint(f\"Server listening on {server_address}\")\n\nwhile True:\n    # Receive data from the client\n    data, client_address = server_socket.recvfrom(1024)\n    print(f\"Received message from {client_address}: {data.decode()}\")\n\n    # Echo the message back to the client\n    server_socket.sendto(data, client_address)\n</code></pre>"},{"location":"socketprogramming/#udp-client","title":"UDP Client","text":"<pre><code>import socket\n\n# Define server address and port\nserver_address = ('localhost', 12345)\n\n# Create a UDP socket\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\nwhile True:\n    # Get user input\n    message = input(\"Enter message to send to server (type 'exit' to quit): \")\n\n    if message.lower() == 'exit':\n        break\n\n    # Send the message to the server\n    client_socket.sendto(message.encode(), server_address)\n\n    # Receive the echoed message from the server\n    data, _ = client_socket.recvfrom(1024)\n    print(f\"Received echoed message: {data.decode()}\")\n\n# Close the socket\nclient_socket.close()\n</code></pre>"},{"location":"socketprogramming/#how-to-achieve-parallelism","title":"How to achieve parallelism","text":""},{"location":"socketprogramming/#python-thread","title":"Python thread","text":"<p>Python, a thread is a lightweight, independent sequence of instructions that can run concurrently with other threads within the same process. Threads enable concurrent execution, allowing tasks to progress simultaneously and make efficient use of resources. Python provides a built-in threading module, which facilitates the creation, management, and synchronization of threads.</p>"},{"location":"socketprogramming/#reading-exercise","title":"Reading exercise","text":"<p>threading \u2014 Thread-based parallelismThread</p>"},{"location":"socketprogramming/#example","title":"Example","text":"<pre><code>def sender():\n# HELLO MESSAGE SENDER THREAD\n    while True:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)\n        sock.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)\n        message=\"HELLO|\"\n        encmessage=message.encode()\n        sock.sendto(encmessage, ('192.168.1.255', 3400))\n        time.sleep(0.8)\n\ndef receiver ():\n# HELLO MESSAGE RECEIVER FUNCTION THREAD\n    UDP_IP = \"\"\n    UDP_PORT = 3400\n    sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) # UDP\n    sock.bind((UDP_IP, UDP_PORT))\n    while True:\n        data, addr = sock.recvfrom(1024) \n        data=data.decode()\n        print(data)\n\nfList=list()\nfList.append(receiver)\nfList.append(sender)\n\nfor funct in fList:\n    th=Thread(target=funct)\n    th.setDaemon(True)\n    th.start()\n</code></pre>"},{"location":"vanetrouting/","title":"VANET Routing","text":"<p>Vehicular Ad Hoc Network (VANET) routing is a critical aspect of intelligent transportation systems, aiming to efficiently manage communication among vehicles on the move. In VANET routing, the challenge lies in establishing reliable and low-latency communication paths to support applications like collision avoidance and traffic management. Dynamic and ever-changing network topologies require adaptive routing protocols, often categorized into proactive, reactive, and hybrid approaches. These protocols leverage vehicle-to-vehicle (V2V) and vehicle-to-infrastructure (V2I) communication to relay information about road conditions, hazards, and traffic patterns. VANET routing plays a pivotal role in enhancing road safety, traffic efficiency, and overall transportation system effectiveness by facilitating seamless and timely data exchange among connected vehicles.</p>"},{"location":"vanetrouting/#flooding-in-vanet","title":"Flooding in VANET","text":"<p>Vehicular Ad Hoc Networks (VANETs) utilize a routing technique known as flooding, where a message originating from a vehicle is broadcasted to all neighboring vehicles within its communication range. This straightforward approach ensures widespread dissemination of information throughout the network. While flooding is robust, it comes with challenges such as high message overhead and potential congestion. Optimizations, including the use of beacons and probabilistic rebroadcast mechanisms, are often employed to enhance efficiency and control the dissemination scope. Effectively managing flooding in VANETs is crucial for striking a balance between reliable information dissemination and resource utilization in dynamic vehicular environments.</p>"},{"location":"vanetrouting/#steps","title":"Steps","text":"<ul> <li>Source node send message</li> <li>Every node contains a receiver module and transmitter module</li> <li>Except destination node, every receiver node retransmit message </li> </ul>"}]}